#!/usr/bin/env bash

# Prüfen, ob eine Datei übergeben wurde
INPUT_FILE="$1"
if [[ -z "$INPUT_FILE" || ! -f "$INPUT_FILE" ]]; then
  echo "Usage: $0 <domain_list.txt>"
  exit 1
fi

# .env laden (falls vorhanden)
[ -f .env ] && export $(grep -v '^#' .env | xargs)
: "${PORT:=443}"
OUT="report.csv"

echo "input_domain,host,puny,ip,mode,rc,status,redir" > "$OUT"

# Die Schleife liest nun aus der Variable INPUT_FILE
while read -r domain || [ -n "$domain" ]; do
  [[ -z "$domain" || "$domain" =~ ^# ]] && continue
  
  clean=$(echo "$domain" | sed -E 's|https?://||; s|/.*||' | tr -d ' \r')
  base="${clean#www.}"

  for host in "$base" "www.$base"; do
    puny=$(python3 -c "import sys; print(sys.stdin.read().strip().encode('idna').decode('ascii'))" <<< "$host")
    
    args=("-sS" "-o" "/dev/null" "-w" "%{http_code} %{redirect_url}" "--connect-timeout" "3")
    [[ -n "$IP" ]] && args+=("--resolve" "$puny:$PORT:$IP")
    
    res=$(curl "${args[@]}" "https://$puny/" 2>/dev/null)
    rc=$?
    mode="secure"

    if [[ $rc -ne 0 || ${res%% *} == "000" ]]; then
      res=$(curl -k "${args[@]}" "https://$puny/" 2>/dev/null)
      rc=$?
      mode="insecure"
    fi

    code=${res%% *}
    redir=${res#* }
    [[ ! "$code" =~ ^30 ]] && redir=""
    
    echo "$clean,$host,$puny,${IP:-DNS},$mode,$rc,${code:-ERR},\"$redir\"" | tee -a "$OUT"
  done
done < "$INPUT_FILE"