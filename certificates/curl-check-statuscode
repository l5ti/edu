#!/usr/bin/env bash
# .env laden (falls vorhanden)
[ -f .env ] && export $(grep -v '^#' .env | xargs)
: "${IP:?IP fehlt}" "${PORT:=443}"
OUT="report.csv"

echo "input_domain,host,puny,ip,mode,rc,status,redir" > "$OUT"

while read -r domain; do
  [[ -z "$domain" || "$domain" =~ ^# ]] && continue
  
  # Clean domain & Basis-Domain (ohne www.)
  clean=$(echo "$domain" | sed -E 's|https?://||; s|/.*||' | tr -d ' \r')
  base="${clean#www.}"

  for host in "$base" "www.$base"; do
    # Punycode via Python-Einzeiler (kürzer als die Funktion oben)
    puny=$(python3 -c "import sys; print(sys.stdin.read().strip().encode('idna').decode('ascii'))" <<< "$host")
    
    # Einmaliger Aufruf mit -k (insecure), um beide Fälle abzudecken, 
    # oder wir nutzen eine kleine Helfer-Variable:
    args=("-sS" "-o" "/dev/null" "-w" "%{http_code} %{redirect_url}" "--connect-timeout" "3" "--resolve" "$puny:$PORT:$IP")
    
    # Versuch 1: Normal
    res=$(curl "${args[@]}" "https://$puny/" 2>/dev/null)
    rc=$?
    mode="secure"

    # Falls fehlgeschlagen (z.B. Zertifikatsfehler), Versuch 2 mit -k
    if [[ $rc -ne 0 || ${res%% *} == "000" ]]; then
      res=$(curl -k "${args[@]}" "https://$puny/" 2>/dev/null)
      rc=$?
      mode="insecure"
    fi

    code=${res%% *}
    redir=${res#* }
    [[ "$code" != 30[12378] ]] && redir=""
    
    echo "$clean,$host,$puny,$IP,$mode,$rc,${code:-ERR},\"$redir\"" | tee -a "$OUT"
  done
done < domains.txt